# Ret2plt:
Ret2plt is a popular exploitation technique derived of ROP / ret2libc but is primarily used on binaries that not only have NX-enabled, but also ASLR. We can check to see if ASLR is on or not with this simple command (You'll need to sudo it more than likely): ``cat /proc/sys/kernel/randomize_va_space``. We can tell if ASLR is set or not if it's a 0 : ``off`` or a 2 : ``on``.

# ASLR (For linux):
What the fuck is ASLR? ASLR stands for: address space layout randomization; any takers on what this means in the context of an executable? Shared object library base address randomize! This completely randomizes where our shared object libraries that are common in a lot of our programs such as libc are now loaded into memory at random places, but this is still able to be bypassed due to the fact that ASLR uses absolute address randomization, so the offsets between function addresses remain the same, just not the place the shared object is loaded into. Now this completely fucks up our older techniques because we hardcoded addresses in our binaries exploit, we cannot do this now due to the fact that ASLR randomizes the base addresses of shared object libraries in our programs addressing space, but not our actual binaries addresses this is another exploit mitigation known as PIE / PIC. So if we cannot hardcode the addresses of which we use for our exploit script, then how can we exploit a vulnerable binary in the first place? Ret2plt I say!!! 

# GOT and PLT:
The ``GOT`` and the ``PLT`` are 2 major aspects of dynamic linking shared object libraries to our binary. These 2 aspects of indirection that's arrived from the problem of: ASLR messing with hardcoded addresses for functions in dynamically linked libraries and having to constantly recompile every single binary that uses said function every time a new libc update is pushed. So how does it work? Your program won't hold the actual code for a function like ``puts``, instead it'll call a ``puts@plt`` stub to either jump to a GOT entry, or resolve a function address that's not already been resolved using ``dl_runtime_resolve_xsave()``. This process is known as lazy binding. Once the function is resolved your program will just jump to the an entry in the GOT which calls the function you desire. Let's visualize this process:

# Lazy binding:
Lazy binding is the process of PLT checking to see if a function address has been resolved or not. Some C pseudo-code would look like this:
```c
_Bool printf@got_resolved = False;

if(printf@got_resolved == False)
{
   push 0x0; // Concurrent index that's pushed every time a symbol is resolved to keep track .dymsym section.
   call dl_runtime_resolve_xsave();
}

else
{
   jmp printf@got;
}
```

# Ret2plt technique demystified: 
This technique is relatively easy once you get the idea of ROP, the PLT, and the GOT; so we remember in our **GOT and PLT** explanation that jumping to the GOT entry of a function inherently calls the function as well, so what we can do is make use of a ``pop rdi ; ret`` gadget, pop the address of the GOT entry onto the stack and into ``rdi`` then we jump to the ``PLT`` stub which jumps to the GOT entry and calls ``puts()`` allowing us to the leak the address of ``puts()`` libc function and print it by calling ``puts()``. After we take this leak and clean formatting of the leaked address that we print to ``stdout`` we can find the other offsets of functions in libc from it and just add and subtract from leaked addresss with other offsets to libc functions to find their real addresses and just ``jmp`` to them, like ``system()`` for example (basic ret2libc after that). This is a really cool and effective technique for bypassing ASLR and NX. So let's see what it looks like:

# Exploitation:

# Shell!!!:
