# PIE / PIC:
What is PIE / PIC? Position independent executable / position independent code (PIE / PIC) is a mechanism that takes over the idea of how the dynamic linker / loader will load your program into memory. See your program is loaded into memory via ld.so, which is the object file for the linux dynamic linker and loader and the loaders job is to figured out where to load your binay into memory at. The purpose of PIE is to randomize the base address of the binary upon run-time thus we cannot hardcode things like symbol addresses or memory addresses inside of the binary. So what does that look like?

# Binary analysis:
```ocaml
   ~/Desktop/binexp/stack/PIE ❯ file demo                                                         2.18   6.17G  100%
demo: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=480d87fd2ece3ab23e4e48fe7eec425fa953c73e, for GNU/Linux 4.4.0, not stripped
```
``pie executable``, this goes to show that this is a PIE exectuable. Let's go into more explanation on how we can really bypass and exploit a program that has PIE enabled.

# Philosophy:
There are 2 prinicples to bypassing PIE:

```1.) Brute-forcing memory addresses, this is a quite effective method but not very efficient or time-efficient method of finding a leaked address.

2.) Arbitrary reads, we can take over things like arbitrary reads / format string vulnerabilities to leak base addresses of our binary which we can use to construct a base to access other things in our binary because PIE only randomizes where our binary is laid out in memory, meaning the offsets are going to be relative to where you are in the binary.```

# Exploitation:
So with this knowledge, let's try to leak a base address which we can make more accurate if we go look at memory mappings to see obtain a general idea of where our binary is placed: 
```asm
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7ddc000   0x00007ffff7dde000   0x0000000000000000 rw- 
0x00007ffff7dde000   0x00007ffff7e04000   0x0000000000000000 r-- /usr/lib/libc-2.33.so
0x00007ffff7e04000   0x00007ffff7f4f000   0x0000000000026000 r-x /usr/lib/libc-2.33.so
0x00007ffff7f4f000   0x00007ffff7f9b000   0x0000000000171000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9b000   0x00007ffff7f9e000   0x00000000001bc000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9e000   0x00007ffff7fa1000   0x00000000001bf000 rw- /usr/lib/libc-2.33.so
0x00007ffff7fa1000   0x00007ffff7fac000   0x0000000000000000 rw- 
0x00007ffff7fc7000   0x00007ffff7fcb000   0x0000000000000000 r-- [vvar]
0x00007ffff7fcb000   0x00007ffff7fcd000   0x0000000000000000 r-x [vdso]
0x00007ffff7fcd000   0x00007ffff7fce000   0x0000000000000000 r-- /usr/lib/ld-2.33.so
0x00007ffff7fce000   0x00007ffff7ff2000    0x0000000000001000 r-x /usr/lib/ld-2.33.so
0x00007ffff7ff2000    0x00007ffff7ffb000    0x0000000000025000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffb000    0x00007ffff7ffd000    0x000000000002d000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffd000    0x00007ffff7fff000    0x000000000002f000 rw- /usr/lib/ld-2.33.so
0x00007ffffffde000    0x00007ffffffff000     0x0000000000000000 rw- [stack]
0xffffffffff600000      0xffffffffff601000      0x0000000000000000 --x [vsyscall]

```
