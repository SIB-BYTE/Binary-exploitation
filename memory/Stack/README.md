# Stack Data Structure / Abstract Data Type:
What in the world is a stack? This is a basic linear abstract data type that follows the behavior of a LIFO structuring; this is a specification of stacks that basically just means the last element pushed on the stack should be the first one popped off of it and vice versa. A way of visualizing a stack, would be to vision a stack of plates and with said stack plates, you can only do 2 operations with said stack and other sub-operations. Those operations include: popping elements (plates) and pushing elements (plates) off and onto the stack. Here's an example:
```c
push(10);
push(20);
push(30);

pop();
pop();

/*
Pushing values onto the stack:

+------+
|      |
|  30  |
|      |
+------+
||||||||
+------+
|      |
|  20  |
|      |
+------+
||||||||
+------+
|      |
|  10  |
|      |
+------+
*/

/*
Popping the values off of the stack.

+------+
|      |
|  10  |
|      |
+------+

*/ 
```
The sub-operations are solely for extra uses like peeking the top element of the stack, checking if it's empty / checking if it's full, et cetera, et cetera. Now onto the applications of stacks in RAM. 

# The stack: 
What is the stack? The stack is a memory region in our programs memory that is. The stack is used to store things like: local variables, passed function parameters, return addresses and function frames. For example: 
```c
int main(void)
{
    int a = 5;
}
``` 

What the function looks like in x86-64 NASM:
```asm
main:                   ; Main label.
push rbp                ; Push the base pointer to reserve it's state. (Meaning we need to preserve the state of it's usage before and after)
mov rbp, rsp            ; Construct a stack frame by moving the stack pointer into the base pointer.
mov DWORD [rbp-4], 5    ; Moving the immediate value of "5" into the 4-bytes space arranged to store values in.
xor eax, eax            ; Return value of main. (0)
pop rbp                 ; Popping the contents of the base pointer back to it's original state.
ret                     ; Returning control-flow to the return address.
```
This assembly is strictly constructing a stack frame prologue and moving 5 from the offset of rbp-4 which looks like this in gdb:
```asm
gefâž¤  x/4x $rbp-4
0x7fffffffe284:	0x00000005	0x00000000	0x00000000	0x00000001
```

# The Stack Layout:
The stack is layed out in a way that grows downwards towards the lower addresses of your addressing space. Now this is depending on your operating system and by 
extension your linker that determines where the stack is loaded at in your processes memory and what direction it actually grows at. See the diagram below:

Asm:
```asm
global _start

section .text
_start:
       call func
func:
       push rbp
       mov rbp, rsp
       nop
       pop rbp
       ret
```

Stack frame for ``func``:
```asm

```

# Stack Allocation for reserved space:
So this is a very wacky topic because people tend to confuse a lot of things with stack allocation such as:
```asm
push rbp
mov rbp, rsp
mov DWORD[rbp-4], immediate value 
mov rsp, rbp
pop rbp
ret
```
As stack allocation, and I will admit even I at one point thought it was as well (but with the thanks of Pete and Manjoos) I had figured that memory on the stack 
is already allocated via loading our process into memory, we just have to reserve areas of stack memory to use. We can do that by adjusting the stack pointer, 
but the direction we adjust the stack pointer depends on our ABI which determines which way the stack grows. See the picture below to see the stack layout: 

![Stack layout](https://ucsd-progsys.github.io/131-web/static/img/stack-layout.png)


(For ease of understanding this picture is displaying a stack frame that's actually upside down, rsp doesn't grow upwards for x86-64)

So here we have a picture of the layout of a stack in virtual memory, as we can see ``rsp`` actually grows lower addresses thus if we want to allocate memory, we need to subtract from ``rsp`` to reserve space for us to use like so:
```asm
sub rsp, 0x16
```
and to deallocate that reserved space we do:
```asm
add rsp, 0x16
```

We primarily reserve space on the stack for things like calling functions so we can have this little space in memory that are our function-call can lay inside of without being tampered with, but once we reserve space we need to dereserve the space we reserve otherwise the stack pointer will be all funky whenever we call ``ret`` which pops the address ``rsp`` is pointing to into ``rip``. Pseudo-code of this would look like this: 

```asm
_start:
    push rbp
    mov rbp, rsp
    sub rsp, 0x16
    push rip
    jmp function
    add rsp, 0x16
    pop rbp
    ret
    
function:
    ; do stuff
    pop rip
```



