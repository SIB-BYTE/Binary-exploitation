# Stack Data Structure / Abstract Data Type:
What in the world is a stack? This is a basic linear abstract data type that follows the behavior of a LIFO structuring; this is a specification of stacks that basically just means the last element pushed on the stack should be the first one popped off of it and vice versa. A way of visualizing a stack, would be to vision a stack of plates and with said stack plates, you can only do 2 operations with said stack and other sub-operations. Those operations include: popping elements (plates) and pushing elements (plates) off and onto the stack. Here's an example:
```c
push(10);
push(20);
push(30);

pop();
pop();

/*
Pushing values onto the stack:

+------+
|      |
|  30  |
|      |
+------+
||||||||
+------+
|      |
|  20  |
|      |
+------+
||||||||
+------+
|      |
|  10  |
|      |
+------+
*/

/*
Popping the values off of the stack.

+------+
|      |
|  10  |
|      |
+------+

*/ 
```
The sub-operations are solely for extra uses like peeking the top element of the stack, checking if it's empty / checking if it's full, et cetera, et cetera. Now onto the applications of stacks in RAM. 

# The stack: 
What is the stack? The stack is a memory region in our programs memory that is. The stack is used to store things like: local variables, passed function parameters, return addresses and function frames. For example: 
```c
int main(void)
{
    int a = 5;
}
``` 

What the function looks like in x86-64 NASM:
```asm
main:                   ; Main label.
push rbp                ; Push the base pointer to reserve it's state. (Meaning we need to preserve the state of it's usage before and after)
mov rbp, rsp            ; Construct a stack frame by moving the stack pointer into the base pointer.
mov DWORD [rbp-4], 5    ; Moving the immediate value of "5" into the 4-bytes space arranged to store values in.
xor eax, eax            ; Return value of main. (0)
pop rbp                 ; Popping the contents of the base pointer back to it's original state.
ret                     ; Returning control-flow to the return address.
```
This assembly is strictly constructing a stack frame prologue and moving 5 in relation to ``rbp-4`` where ever in the fuck that may be, let's take a look in gdb:
```asm
gefâž¤  x/4x $rbp-4
0x7fffffffe284:	0x00000005	0x00000000	0x00000000	0x00000001
```

# The Stack Layout:
The stack is layed out in a way that grows downwards towards the lower addresses of your addressing space. Now this is depending on your operating system and by 
extension your linker that determines where the stack is loaded at in your processes memory and what direction it actually grows at. See the diagram below:

C:
```c
void function(void)
{
    int a = 5;
}

int main(void)
{
    int a = 10;
    function();
}
```

ASM:
```asm
function: 
push rbp
mov rbp, rsp
mov DWORD[rbp-4], 5
pop rbp
ret

main:
push rbp
mov rbp, rsp
sub rsp, 16
mov DWORD[rbp-4], 10
call function
xor eax, rax
mov rsp, rbp
pop rbp
ret
```

# Stack Allocation for reserved space:
So this is a very wacky topic because people tend to confuse a lot of things with stack allocation such as:
```asm
push rbp
mov rbp, rsp
mov DWORD[rbp-4], immediate value 
mov rsp, rbp
pop rbp
ret
```
Here we see that this assembly code is pushing a stack function prologue (``push rbp``), which basically just sets up our own specific indiviual instances of a stack frame, without any other interactions of any other stack frames, then we are moving in ``rsp`` into ``rbp`` to create a new instance of a stack frame not relevant to the previous stack frame. Then moving an immediate value onto the stack. Then we do a function prologue ``mov rsp, rbp`` and ``pop rbp`` which sets up our stack frame for the next initialization of a stack frame. Stack frames are such a popular concept the x86-64 implemented 2 stack instructions which are: ``enter`` and ``leave`` which is basically just this:
```asm
enter:
mov rbp, rsp
```
and
```asm
leave:
mov rsp, rbp
pop rbp
```

As stack allocation, and I will admit even I at one point thought it was as well (but with the thanks of Pete and Manjoos) I had figured that memory on the stack 
is already allocated via loading our process into memory, we just have to reserve areas of stack memory to use. We can do that by adjusting the stack pointer, 
but the direction we adjust the stack pointer depends on our ABI which determines which way the stack grows. See the picture below to see the stack layout: 

![Stack layout](https://ucsd-progsys.github.io/131-web/static/img/stack-layout.png)

(For ease of understanding this picture is displaying a stack frame that's actually upside down, rsp doesn't grow upwards for x86-64)

So here we have a picture of the layout of a stack in virtual memory, as we can see ``rsp`` actually grows towards lower addresses to store more things thus if we want to reserve the allocated stack memory, we need to subtract from ``rsp`` to reserve space for us to use like so:
```asm
sub rsp, 0x8
```
and to deallocate that reserved space we do:
```asm
add rsp, 0x8
```

The offset of which you add / subtract by depends on your stack byte-boundary, which for x86-64 the byte-boundary is 8 bytes, so for subtractig and adding bytes to / from ``rsp``, use multiples of 8. (For x86 I believe the byte boundary is half of what it is for x86-64 thus 4 being the offset for those systems)

We primarily reserve space on the stack for things like calling functions so we can have this little space in memory that are our function-call can lay inside of without being tampered with, but once we reserve space we need to dereserve the space we reserve otherwise the stack pointer will be all funky whenever we call ``ret`` which pops the address ``rsp`` is pointing to into ``rip``. Pseudo-code of this would look like this: 

```asm
_start:
push rbp
mov rbp, rsp
    
sub rsp, 16
push rip
jmp function
    
mov rsp, rbp
pop rbp
ret
    
function:
ret
```

So if a function like so:
```c
void function(void)
{
    int a = 5;
    function2();
}
```
Will need to subtract space from the stack pointer to preserve the space of the function-call so nothing will actually mess with the contents of the stack. Now if we don't allocate a variable and try to call a function there will be no space required because there will be nothing to fuck with from other stack frames, like so:
```c
void function(void)
{
    function2();
}
```

This here won't subtract anything from ``rsp``, because we're not allocating anything on the stack; I believe this is some form an optimization but if we were to 
have something on the stack then called another function then we'd have to subtract space. But in this demonstration we don't.

# The End!!!
Main points:

1.) The stack is a memory structure that is a part of program memory and an abstract data type that is a LIFO / FILO structure type.

2.) The stack has 2 main operations: pop and push for pushing and popping elements.

3.) The stack grows downwards towards lower memory addresses in the virtual memory addressing space.

4.) You subtract from ``rsp`` only if you're in a function that isn't the last in the call-chain, or you put variables on the stack and call a function. So 
basically: Not the last function in the call-chain && you're putting things on the stack = subtraction from ``rsp``. Anything else = No subtraction from ``rsp``. 

5.) You need to ``mov rsp, rbp`` for every ``mov rbp, rsp`` just so long as you're utilizing things on the stack. You also need to ``add`` what you ``sub`` from ``rsp``, or restore the preserved state of the stack frame via ``mov rsp, rbp`` or ``add`` back what you subtracted. 

Please contact me on discord: ``f(x)#1006`` if any of this information is wrong or not direct or precise enough. 
