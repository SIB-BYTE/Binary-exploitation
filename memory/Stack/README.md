# Stack Data Structure / Abstract Data Type:
What in the world is a stack? This is a basic linear abstract data type that follows the behavior of a LIFO structuring; this is a specification of stacks that basically just means the last element pushed on the stack should be the first one popped off of it and vice versa. A could way of visualizing a stack, would be to vision a stack of plates and with said stack plates, you can only do 2 operations with said stack and other sub-operations. Those operations include: popping elements (plates) and pushing elements (plates) off and onto the stack. Here's an example:
```c
push(10)
push(20)
push(30)

pop()
pop()

Graph:
/* Pushing values onto the stack. */

+------+
|      |
|  30  |
|      |
+------+
||||||||
+------+
|      |
|  20  |
|      |
+------+
||||||||
+------+
|      |
|  10  |
|      |
+------+

/* Popping the values off of the stack. */

+------+
|      |
|  10  |
|      |
+------+
```
The sub-operations are solely for extra uses like peeking the top element of the stack, checking if it's empty / checking if it's full, et cetera, et cetera. Now onto the applications of stacks in RAM. 

# Call-Stack: 
What is a call-stack? A call-stack is a memory region in our programs memory that is . A call-stack or "The stack" is used to store things like: local variables, passed function parameters when needed, return addresses and function frames. For example: 
```c
int main(void)
{
    int a = 5;
}
``` 

What the function looks like in x86-64 NASM:
```asm
main (void):
push rbp                ; Push the base pointer to reserve it's state. (Meaning we need to preserve the state of it's usage before and after)
mov rbp, rsp            ; Construct a stack frame by moving the stack pointer into the base pointer.
mov DWORD [rbp-4], 5    ; Moving the immediate value of "5" into the 4-bytes space arranged to store values in.
pop rbp                 ; Popping the contents of the base pointer back to it's original state.
ret                     ; Returning control-flow to the return address.
```
This assembly is strictly constructing a stack frame prologue and moving 5 from the offset of rbp-4 which looks like this in gdb:
```asm
gefâž¤  x/4x $rbp-4
0x7fffffffe284:	0x00000005	0x00000000	0x00000000	0x00000001
```

# The Stack Layout:
The stack is layed out in a way that grows downwards towards the lower addresses of your addressing space. Now this is depending on your operating system and by 
extension your linker that determines where the stack is loaded at in your processes memory and what direction it actually grows at. See the diagram below:

Asm:
```asm
global _start

section .text
_start:
       call func
func:
       push rbp
       mov rbp, rsp
       nop
       pop rbp
       ret
```

```
Stack frame for "func":

Higher addresses [0xff..]
+=====================+
|                     |
|   Return address    |<=====================+
|                     |                      |
|---------------------| <==== rbp / ebp      |
| Base pointer        | push rbp             |
|                     | mov rbp, rsp         | Return back to that return address.
|                     | nop                  |
|                     | pop rbp              |
| Stack pointer       | ret =================+
+=====================+ <==== rsp / esp
|    Red zone         |
|                     | 
+---------------------+
Lower addresses [0x00..]
```

# Stack Allocations:

