# The Heap:
What is the heap? The heap is a dynamically allocated memory structure that is put in place upon run-time from libc with the usage of your memory allocators API interface functions namely: ``malloc``, ``calloc`` and ``realloc``. The heap is used in order to store data in a longer time-period than things on the stack do. Objects only last as long as the frame of the function lasts, after that your stack objects are deconstructed along with the stack frame itself. Not the case with the heap, it doesn't simply go away, we can make requests to the heap allocator for size-specified chunks that we can cache back to the heap allocator via using the ``free`` interface function. (I'll go more into specification regarding the ``free`` and ``malloc`` interface functions internals in a separate directory.)

Where is the heap located? It's located in a segment of your programs memory that's above the sections that store program relative data such as initalized global data, uninitalized global data and your instructions (.data, .bss and .text): 
![User-space memory](http://i.stack.imgur.com/cBKU6.png) 

// Keep in mind your heap doesn't have to be in this exact location, hell none of this has to be in this exact location, your linker and loader decides what gets stored where and how it's loaded in memory in such a way. Your ABI determines the format of the executable once laid in memory as well.

What does it looks like and how do we know we're using it? Okay so given this program here: 
```c
#include <stdlib.h>

int main(void)
{
  void *chunk_ptr = malloc(16); // Allocating 16-bytes worth of usable heap-chunk space. (That's not that's all allocated, just what's able to be used)
  *(int *) chunk_ptr = 5;       // Taking the first byte-segment of the heap chunk and assigning the value 5 to the segment.
  free(chunk_ptr);              // Freeing the pointer of the allocated heap chunk back to the heap allocator so there is no memory leak.
}
```


What is a memory leak? A memory leak is whenever we don't cache the allocated chunk that our program allocates upon run-time, thus our operating system will have these reserved addresses in our programs memory addressing space that we aren't used anymore, thus we run into performance issues because we're occupying memory addresses that aren't being used. This is what a memory leak looks like in C and in valgrind: 
```c
#include <stdlib.h>

int main(void)
{
	void *ptr = malloc(16);
	*(int *) ptr = 5;
}
```
```c
   ~/Desktop/binexp/stack ❯ valgrind --leak-check=full ./test                                                                3.40   5.75G  100%
==89666== Memcheck, a memory error detector
==89666== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==89666== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==89666== Command: ./test
==89666== 
==89666== 
==89666== HEAP SUMMARY:
==89666==     in use at exit: 16 bytes in 1 blocks
==89666==   total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==89666== 
==89666== 16 bytes in 1 blocks are definitely lost in loss record 1 of 1
==89666==    at 0x483E7C5: malloc (vg_replace_malloc.c:380)
==89666==    by 0x109146: main (in /home/layta/Desktop/binexp/stack/test)
==89666== 
==89666== LEAK SUMMARY:
==89666==    definitely lost: 16 bytes in 1 blocks
==89666==    indirectly lost: 0 bytes in 0 blocks
==89666==      possibly lost: 0 bytes in 0 blocks
==89666==    still reachable: 0 bytes in 0 blocks
==89666==         suppressed: 0 bytes in 0 blocks
==89666== 
==89666== For lists of detected and suppressed errors, rerun with: -s
==89666== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```
