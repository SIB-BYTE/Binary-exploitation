# The Heap:
What is the heap? The heap is a dynamically allocated memory structure that is put in place upon run-time from libc with the usage of your memory allocators API interface functions namely: ``malloc``, ``calloc`` and ``realloc``. The heap is used in order to store data in a longer time-period than things on the stack do. Objects only last as long as the frame of the function lasts, after that your stack objects are deconstructed along with the stack frame itself. Not the case with the heap, it doesn't simply go away, we can make requests to the heap allocator for size-specified chunks that we can cache back to the heap allocator via using the ``free`` interface function. (I'll go more into specification regarding the ``free`` and ``malloc`` interface functions internals in a separate directory.)

Where is the heap located? It's located in a segment of your programs memory that's above the sections that store program relative data such as initalized global data, uninitalized global data and your instructions (.data, .bss and .text): 
![User-space memory](http://i.stack.imgur.com/cBKU6.png) 

// Keep in mind your heap doesn't have to be in this exact location, hell none of this has to be in this exact location, your linker and loader decides what gets stored where and how it's loaded in memory in such a way. Your ABI determines the format of the executable once laid in memory as well.

What does it looks like and how do we know we're using it? Okay so given this program here: 
```c
#include <stdlib.h>

int main(void)
{
  void *chunk_ptr = malloc(16); // Allocating 16-bytes worth of usable heap-chunk space. (That's not that's all allocated, just what's able to be used)
  *(int *) chunk_ptr = 5;       // Taking the first byte-segment of the heap chunk and assigning the value 5 to the segment.
  free(chunk_ptr);              // Freeing the pointer of the allocated heap chunk back to the heap allocator so there is no memory leak.
}
```
So that's what it looks like to use it, let's see some virtual memory mappings to see what the run-time heap looks like. Lets hop into gdb:
```x86asm
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/layta/Desktop/binexp/stack/test
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/layta/Desktop/binexp/stack/test
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/layta/Desktop/binexp/stack/test
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/layta/Desktop/binexp/stack/test
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/layta/Desktop/binexp/stack/test
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7ddc000   0x00007ffff7dde000   0x0000000000000000 rw- 
0x00007ffff7dde000   0x00007ffff7e04000   0x0000000000000000     r-- /usr/lib/libc-2.33.so
0x00007ffff7e04000   0x00007ffff7f4f000   0x0000000000026000 r-x /usr/lib/libc-2.33.so
0x00007ffff7f4f000   0x00007ffff7f9b000   0x0000000000171000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9b000   0x00007ffff7f9e000   0x00000000001bc000 r-- /usr/lib/libc-2.33.so
0x00007ffff7f9e000   0x00007ffff7fa1000   0x00000000001bf000 rw- /usr/lib/libc-2.33.so
0x00007ffff7fa1000   0x00007ffff7fac000   0x0000000000000000 rw- 
0x00007ffff7fc7000   0x00007ffff7fcb000   0x0000000000000000 r-- [vvar]
0x00007ffff7fcb000   0x00007ffff7fcd000   0x0000000000000000 r-x [vdso]
0x00007ffff7fcd000   0x00007ffff7fce000   0x0000000000000000 r-- /usr/lib/ld-2.33.so
0x00007ffff7fce000   0x00007ffff7ff2000    0x0000000000001000 r-x /usr/lib/ld-2.33.so
0x00007ffff7ff2000    0x00007ffff7ffb000    0x0000000000025000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffb000    0x00007ffff7ffd000    0x000000000002d000 r-- /usr/lib/ld-2.33.so
0x00007ffff7ffd000    0x00007ffff7fff000    0x000000000002f000 rw- /usr/lib/ld-2.33.so
0x00007ffffffde000    0x00007ffffffff000     0x0000000000000000 rw- [stack]
0xffffffffff600000      0xffffffffff601000      0x0000000000000000 --x [vsyscall]
```
At address: ``0x0000555555559000`` is where the top of the heap is located in our program's memory. Notice we try to keep it as far away from the stack as we can so we can hopefully avoid crashing into the stack. (Not for fun and profit. [Yet....])

What is a memory leak? A memory leak is whenever we don't cache the allocated chunk that our program allocates upon run-time, thus our operating system will have these reserved addresses in our programs memory addressing space that we aren't used anymore, thus we run into performance issues because we're occupying memory addresses that aren't being used. This is what a memory leak looks like in C and in valgrind: 
```c
#include <stdlib.h>

int main(void)
{
	void *ptr = malloc(16);
	*(int *) ptr = 5;
}
```
```c
   ~/Desktop/binexp/stack ❯ valgrind --leak-check=full ./test                                                                3.40   5.75G  100%
==89666== Memcheck, a memory error detector
==89666== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==89666== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==89666== Command: ./test
==89666== 
==89666== 
==89666== HEAP SUMMARY:
==89666==     in use at exit: 16 bytes in 1 blocks
==89666==   total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==89666== 
==89666== 16 bytes in 1 blocks are definitely lost in loss record 1 of 1
==89666==    at 0x483E7C5: malloc (vg_replace_malloc.c:380)
==89666==    by 0x109146: main (in /home/layta/Desktop/binexp/stack/test)
==89666== 
==89666== LEAK SUMMARY:
==89666==    definitely lost: 16 bytes in 1 blocks
==89666==    indirectly lost: 0 bytes in 0 blocks
==89666==      possibly lost: 0 bytes in 0 blocks
==89666==    still reachable: 0 bytes in 0 blocks
==89666==         suppressed: 0 bytes in 0 blocks
==89666== 
==89666== For lists of detected and suppressed errors, rerun with: -s
==89666== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```
